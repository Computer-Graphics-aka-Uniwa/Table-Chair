<!DOCTYPE HTML>
<html>
	<head>
		<meta charset="UTF-8">
		<script src="WebGL-Libraries/gl-matrix-min.js"></script>
		<script src="WebGL-Libraries/webgl-debug.js"></script>

		<script id="vShader" type="x-shader/x-vertex">
			attribute vec4 aVertexPosition;
			// NEW 1. Addition of the attribute for texture coordinates
			attribute vec2 aTextureCoord;
			uniform mat4 uPerspectiveViewMatrix;
			uniform mat4 uVerticesTransform;
			// NEW 2. Addition of the varying for texture coordinates
			varying vec2 vTextureCoord;
			void main() {
				gl_Position = uPerspectiveViewMatrix * uVerticesTransform * aVertexPosition;
				// NEW 3. Copying the texture coordinates to the varying
				vTextureCoord = aTextureCoord;
			}
		</script>

		<script id="fShader" type="x-shader/x-vertex">
			precision mediump float;
			// NEW 4. Addition of the varying for texture coordinates
			varying vec2 vTextureCoord;
			// NEW 5. Addition of the sampler for the image
			uniform sampler2D uSampler;
			void main() {
				// NEW 6. Using the texture coordinates to read the image
				gl_FragColor = texture2D(uSampler, vTextureCoord);
			}
		</script>

		<script>
			var gl;
			var canvas;
			var shadersProgram;
			
			var vertexPositionAttributePointer;
			var vertexColorAttributePointer;
			var verticesTransformUniformPointer;
			
			var vertexBuffer;
			var indexBuffer;

			var scalingMatrix = new Float32Array(16);
			var translationMatrix = new Float32Array(16);
			var finalMatrix = new Float32Array(16);
			
			var totalAngle = 0.0;
			var isRedraw = false;
			// NEW 7. Declaration of the animation flag that indicates whether the animation is active or not
			var requestID = 0;
			
			var viewMatrix = new Float32Array(16);
			var perspectiveMatrix = new Float32Array(16);
			var pvMatrix = new Float32Array(16);
			
			var perspectiveViewUniformPointer;
			var viewUniformPointer;
			
			var cameraPositionCoordinates = [0,0,0];
			
			// NEW 8. Declaration of the buffers for the textures
			var textureCoordAttributePointer;
			// NEW 9. Declaration of the sampler pointer for the uniform location in the fragment shader
			var uSamplerUniformPointer;
			// NEW 10. Declaration of the buffer for the texture coordinates
			var textureBuffer;
			// NEW 11. Declaration of the textures
			var tableTexture;
			var chairTexture;
			

			function createGLContext(inCanvas) {
				var outContext = null;
				outContext = inCanvas.getContext("webgl");
				if (!outContext)
					outContext = inCanvas.getContext("experimental-webgl");
				if (!outContext)
					alert("WebGL rendering context creation error.");

				return outContext;
			}

			function createCompileShader(shaderType, shaderSource) {
				var outShader = gl.createShader(shaderType);
				gl.shaderSource(outShader, shaderSource);
				gl.compileShader(outShader);
				if (!gl.getShaderParameter(outShader, gl.COMPILE_STATUS)) {
					alert("Shader compilation error. " + gl.getShaderInfoLog(outShader));
					gl.deleteShader(outShader);
					outShader = null;
				}

				return outShader;
			}

			function initShaders() {
				var vertexShaderSource = document.getElementById("vShader").textContent;
				var fragmentShaderSource = document.getElementById("fShader").textContent;
				var vertexShader = createCompileShader(gl.VERTEX_SHADER, vertexShaderSource);
				var fragmentShader = createCompileShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
				shadersProgram = gl.createProgram();
				gl.attachShader(shadersProgram, vertexShader);
				gl.attachShader(shadersProgram, fragmentShader);
				gl.linkProgram(shadersProgram);
				if (!gl.getProgramParameter(shadersProgram, gl.LINK_STATUS)) {
					alert("Shaders linking error.");
				}
				gl.useProgram(shadersProgram);
				vertexPositionAttributePointer = gl.getAttribLocation(shadersProgram, "aVertexPosition");
				gl.enableVertexAttribArray(vertexPositionAttributePointer);
				// NEW 12. Reading the attribute for the texture coordinates
				textureCoordAttributePointer = gl.getAttribLocation(shadersProgram, "aTextureCoord");
				gl.enableVertexAttribArray(textureCoordAttributePointer);
				verticesTransformUniformPointer = gl.getUniformLocation(shadersProgram, "uVerticesTransform");
				// NEW 13. Reading the sampler for the image
				uSamplerUniformPointer = gl.getUniformLocation(shadersProgram, "uSampler");
			}

			function initBuffers() {
				var cubePositions = new Float32Array ([
					// Back side
					-1.0, -1.0, 1.0, 1.0,
        			1.0, -1.0, 1.0, 1.0,
        			1.0, 1.0, 1.0, 1.0,
        			-1.0, 1.0, 1.0, 1.0,
					// Right side
					1.0, -1.0, -1.0, 1.0,
					1.0, -1.0, 1.0, 1.0,
					1.0, 1.0, 1.0, 1.0,
					1.0, 1.0, -1.0, 1.0,
					// Front side
					1.0, -1.0, -1.0, 1.0,
					-1.0, -1.0, -1.0, 1.0,
					-1.0, 1.0, -1.0, 1.0,
					1.0,  1.0, -1.0, 1.0,
					// Left side
					-1.0, -1.0, -1.0, 1.0,
					-1.0, -1.0, 1.0, 1.0,
					-1.0, 1.0, 1.0, 1.0,
					-1.0, 1.0, -1.0, 1.0,
					// Bottom side
					-1.0, -1.0, 1.0, 1.0,
					1.0, -1.0, 1.0, 1.0,
					1.0, -1.0, -1.0, 1.0,
					-1.0, -1.0, -1.0, 1.0,
					// Top side
					-1.0, 1.0, 1.0, 1.0,
					1.0, 1.0, 1.0, 1.0,
					1.0, 1.0, -1.0, 1.0,
					-1.0,  1.0, -1.0, 1.0
    			]);

				vertexBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, cubePositions, gl.STATIC_DRAW);
				vertexBuffer.itemSize = 4;
				vertexBuffer.numItems = 24;

				indexBuffer = gl.createBuffer();
				var indexMatrix = new Uint16Array ([
					0, 1, 2, 0, 2, 3,
					4, 5, 6, 4, 6, 7,
					8, 9, 10, 8, 10, 11,
					12, 13, 14, 12, 14, 15,
					16, 17, 18, 16, 18, 19,
					20, 21, 22, 20, 22, 23
				]);

				indexBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexMatrix, gl.STATIC_DRAW);
				indexBuffer.itemSize = 1;
				indexBuffer.numItems = 36;

				// NEW 14. Creation of the buffer for the texture coordinates
				var textureCoordinates = new Float32Array([
					// Back side
					0.0, 0.0,
					1.0, 0.0,
					1.0, 1.0,
					0.0, 1.0,
					// Right side
					0.0, 0.0,
					1.0, 0.0,
					1.0, 1.0,
					0.0, 1.0,
					// Front side
					0.0, 0.0,
					1.0, 0.0,
					1.0, 1.0,
					0.0, 1.0,
					// Left side
					0.0, 0.0,
					1.0, 0.0,
					1.0, 1.0,
					0.0, 1.0,
					// Bottom side
					0.0, 0.0,
					1.0, 0.0,
					1.0, 1.0,
					0.0, 1.0,
					// Top side
					0.0, 0.0,
					1.0, 0.0,
					1.0, 1.0,
					0.0, 1.0
				]);

				textureBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, textureCoordinates, gl.STATIC_DRAW);
				textureBuffer.itemSize = 2;

				// NEW 15. Preprocessing of the textures
				tableTexture = gl.createTexture();
				var tableTextureURL = "textures/Table_Texture.jpg";
				preprocessTextureImage(tableTextureURL, tableTexture);

				chairTexture = gl.createTexture();
				var chairTextureURL = "textures/Chair_Texture.jpg";
				preprocessTextureImage(chairTextureURL, chairTexture);
			}

			// NEW 16.1 Custom function for linking a texture object with an image and preprocessing the image
			function preprocessTextureImage(imageURL, textureObject) {
				var imageObject = new Image();
				
				imageObject.onload = function() {    
					gl.bindTexture(gl.TEXTURE_2D, textureObject);	
					gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
					gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, imageObject);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
					gl.generateMipmap(gl.TEXTURE_2D);
				};

				imageObject.src = imageURL;	
			}

			function drawScene() {
				gl.useProgram(shadersProgram);
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
				gl.enable(gl.DEPTH_TEST);
				
				gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
				gl.vertexAttribPointer(vertexPositionAttributePointer, vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

				// In case the user is not pressing the "Redraw" button, set the default values
				if (!isRedraw) {
					glMatrix.mat4.lookAt(viewMatrix, [9,9,9], [0,0,0], [0,0,1]);
					glMatrix.mat4.perspective(perspectiveMatrix, 80 * Math.PI / 180, 1, 0.01, 1000);
				}
				glMatrix.mat4.multiply(pvMatrix, perspectiveMatrix, viewMatrix);

				perspectiveViewUniformPointer = gl.getUniformLocation(shadersProgram, "uPerspectiveViewMatrix");
				gl.uniformMatrix4fv(perspectiveViewUniformPointer, false, pvMatrix);;

				// NEW 17. Reading the buffer for the table's texture coordinates
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, tableTexture);
				gl.uniform1i(uSamplerUniformPointer, 0);

				// Drawing Table
				drawTableChair([9.5, 9.5, 0], [0.5, 0.5, 7.5], textureBuffer);
				drawTableChair([-9.5, 9.5, 0], [0.5, 0.5, 7.5], textureBuffer);
				drawTableChair([-9.5, -9.5, 0], [0.5, 0.5, 7.5], textureBuffer);
				drawTableChair([9.5, -9.5, 0], [0.5, 0.5, 7.5], textureBuffer);
				drawTableChair([0, 0, 8], [10, 10, 0.5], textureBuffer);

				// NEW 18. Reading the buffer for the chair's texture coordinates
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, chairTexture);
				gl.uniform1i(uSamplerUniformPointer, 1);

				// Drawing Chair
				drawTableChair([-5.25, 4, -3], [0.25, 0.25, 3.75], textureBuffer);
				drawTableChair([-14.75, 4, -3], [0.25, 0.25, 3.75], textureBuffer);
				drawTableChair([-14.75, -5.5, -3], [0.25, 0.25, 3.75], textureBuffer);
				drawTableChair([-5.25, -5.5, -3], [0.25, 0.25, 3.75], textureBuffer);
				drawTableChair([-10, -0.75, 1], [5, 5, 0.25], textureBuffer);
				drawTableChair([-14.75, -0.75, 5], [0.25, 5, 3.75], textureBuffer);
			}

			function drawTableChair(localTranslationMatrix, localScalingMatrix, localTextureBuffer) {
				glMatrix.mat4.fromTranslation(translationMatrix, localTranslationMatrix);
				glMatrix.mat4.fromScaling(scalingMatrix, localScalingMatrix);
				glMatrix.mat4.multiply(finalMatrix, translationMatrix, scalingMatrix);
				gl.uniformMatrix4fv(verticesTransformUniformPointer, false, finalMatrix);
				
				gl.bindBuffer(gl.ARRAY_BUFFER, localTextureBuffer);
				gl.vertexAttribPointer(textureCoordAttributePointer, localTextureBuffer.itemSize, gl.FLOAT, false, 0, 0);
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
				
				gl.drawElements(gl.TRIANGLES, indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
			}

			function redrawScene() {
				var viewAngle;
				var viewDistance;
				var cameraPosition;

				viewAngle = parseFloat(document.getElementById("viewAngleTxt").value);
				viewDistance = parseFloat(document.getElementById("viewDistanceTxt").value);
				cameraPosition = document.querySelector('input[name="cameraPosition"]:checked').value;

				switch (cameraPosition) {
					case 'LFT': // Left-Front-Top
						cameraPositionCoordinates = [-viewDistance, viewDistance, viewDistance];
						break;
					case 'LFB': // Left-Front-Bottom
						cameraPositionCoordinates = [-viewDistance, viewDistance, -viewDistance];
						break;
					case 'LBT': // Left-Back-Top
						cameraPositionCoordinates = [-viewDistance, -viewDistance, viewDistance];
						break;
					case 'LBB': // Left-Back-Bottom
						cameraPositionCoordinates = [-viewDistance, -viewDistance, -viewDistance];
						break; 
					case 'RFT': // Right-Front-Top
						cameraPositionCoordinates = [viewDistance, viewDistance, viewDistance];
						break;
					case 'RFB': // Right-Front-Bottom
						cameraPositionCoordinates = [viewDistance, viewDistance, -viewDistance];
						break;
					case 'RBT': // Right-Back-Top
						cameraPositionCoordinates = [viewDistance, -viewDistance, viewDistance];
						break;
					case 'RBB': // Right-Back-Bottom
						cameraPositionCoordinates = [viewDistance, -viewDistance, -viewDistance];
						break;
					default:
						cameraPositionCoordinates = [9, 9, 9];
						break;
				}
				
				// We redraw the scene with the selected user values
				glMatrix.mat4.lookAt(viewMatrix, cameraPositionCoordinates, [0,0,0], [0,0,1]);
				glMatrix.mat4.perspective(perspectiveMatrix, viewAngle * Math.PI / 180, 1, 0.01, viewAngle * 100);
				isRedraw = true;
				drawScene();
			}

			// NEW 19. Function for executing the animation
			function drawSceneWithAnimation() {
				totalAngle += 0.01;
				var r = Math.sqrt(cameraPositionCoordinates[0] * cameraPositionCoordinates[0] + cameraPositionCoordinates[1] * cameraPositionCoordinates[1]);
				var x = r * Math.cos(totalAngle);
				var y = r * Math.sin(totalAngle);
				var z = cameraPositionCoordinates[2];
				glMatrix.mat4.lookAt(viewMatrix, [x, y, z], [0,0,0], [0,0,1]);
				glMatrix.mat4.perspective(perspectiveMatrix, 80 * Math.PI / 180, 1, 0.01, 1000);
				drawScene();
			}

			function main() {
				var minDimension;
				minDimension = Math.min(window.innerHeight, window.innerWidth);
				canvas = document.getElementById("sceneCanvas");
				canvas.width = 0.9 * minDimension;
				canvas.height = 0.9 * minDimension;
				gl = WebGLDebugUtils.makeDebugContext(createGLContext(canvas));
				initShaders();
				initBuffers();
				gl.clearColor(0.3, 0.3, 0.3, 1.0);
				gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
				gl.enable(gl.DEPTH_TEST);
				drawScene();
			}

			// NEW 20. Function to start the animation
			function startAnimation() {
				if (requestID == 0)
					requestID = window.requestAnimationFrame(animationStep);
			}

			// NEW 21. Function for executing the animation
			function animationStep() {
				drawSceneWithAnimation();
				requestID = window.requestAnimationFrame(animationStep);
			}

			// NEW 22. Function to stop the animation
			function stopAnimation() {
				window.cancelAnimationFrame(requestID);
				requestID = 0;
			}
		</script>
	</head>
	<body onload="main()">
		<canvas id="sceneCanvas"></canvas>
		<p>
			View angle (in degrees): <input type="text" id="viewAngleTxt" value="90" autocomplete="off">
			Orthogonal distance of the camera: <input type="text" id="viewDistanceTxt" value="20" autocomplete="off">
		</p>
		<p>
			Camera position: 
			<input type="radio" id="LFT" name="cameraPosition" value="LFT" checked>
			<label for="LFT">Left-Front-Top</label>
			<input type="radio" id="LFB" name="cameraPosition" value="LFB">
			<label for="LFB">Left-Front-Bottom</label>
			<input type="radio" id="LBT" name="cameraPosition" value="LBT">
			<label for="LBT">Left-Back-Top</label>
			<input type="radio" id="LBB" name="cameraPosition" value="LBB">
			<label for="LBB">Left-Back-Bottom</label>
			<input type="radio" id="RFT" name="cameraPosition" value="RFT">
			<label for="RFT">Right-Front-Top</label>
			<input type="radio" id="RFB" name="cameraPosition" value="RFB">
			<label for="RFB">Right-Front-Bottom</label>
			<input type="radio" id="RBT" name="cameraPosition" value="RBT">
			<label for="RBT">Right-Back-Top</label>
			<input type="radio" id="RBB" name="cameraPosition" value="RBB">
			<label for="RBB">Right-Back-Bottom</label>
		</p>
		<p>
			<button id="drawSceneButton" onclick="redrawScene()">Redraw</button>
		</p>
		<p>
			<button id="startAnimationButton" onclick="startAnimation()">Start</button>
			<button id="stopAnimationButton" onclick="stopAnimation()">Stop</button>
		</p>
	</body>
</html>